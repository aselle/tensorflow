load("//tensorflow/compiler/aot:tfcompile.bzl", "tf_library")

#package(default_visibility = ["//tensorflow:internal"])
#package(default_visibility = ["//visibility:public"])
package(default_visibility = ["//visibility:public"])


py_binary(
    name = "gesture",
    srcs = ["gesture.py"],
    deps = [
      "//tensorflow:tensorflow_py"
    ]
)

# Use the tf_library macro to compile your graph into executable code.
tf_library(
    name = "gesturelib",
    # cpp_class specifies the name of the generated C++ class, with namespaces allowed.
    # The class will be generated in the given namespace(s), or if no namespaces are
    # given, within the global namespace.
    cpp_class = "Examples::Gesture",
    # graph is the input GraphDef proto, by default expected in binary format.  To
    # use the text format instead, just use the ‘.pbtxt’ suffix.  A subgraph will be
    # created from this input graph, with feeds as inputs and fetches as outputs.
    # No Placeholder or Variable ops may exist in this subgraph.
    graph = "gesture_frozen.pb",
    # config is the input Config proto, by default expected in binary format.  To
    # use the text format instead, use the ‘.pbtxt’ suffix.  This is where the
    # feeds and fetches were specified above, in the previous step.
    config = "gesture.config.pbtxt",
)

# The executable code generated by tf_library can then be linked into your code.
cc_binary(
    name = "gesture_simple",
    srcs = [
      "gesture_simple.cc",  # include test_graph_tfmatmul.h to access the generated header
    ],
    deps = [
      ":gesturelib",  # link in the generated object file
      "//third_party/eigen3",
    ],
    includes = [
      "gesture.h"
    ] ,
    linkopts = [     "-lpthread"]
)
